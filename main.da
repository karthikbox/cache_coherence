import sys
import time
import os

ENOTSUPP = 2
CACHE_SIZE = 512

def get_proto_class(name):
  if name == "MI":
    return (eval("MI_PROTO_CACHE"), eval("MI_PROTO_CTRL"))
  else:
    exit(-ENOTSUPP)

## Exemplary implementation of PROTOCOL Classes
"""
  MI Protocol class:
"""
class MI_PROTO_CACHE(process):
  def setup(dir_ctrlr, other_caches, size,monitor_obj):
    self.memory = []
    
    self.pending_actions=[]
    self.current_state="READY"
    
    
  def run():
    while(1):
      await(len(self.pending_actions)>0 and current_state=="READY")
      #queue has some pending request and  state is READY
      #process request
      processRequest()

  def processRequest():
    #deque request
    # (inst,addr,to_process,data)=pending_actions.pop(0)
    t=pending_actions.pop(0)
    inst=t[0]
    addr=t[1]
    to_process=t[2]
    #possible instructions are : loads,stores, invalidate
    if inst=='inv':
      perform_invalidation(addr,to_process)
    elif inst=='load':
      perform_load(addr,to_process)
    elif inst=='store':
      perform_store(addr,to_process,t[3])
    elif inst=='fwd_gets':
      perform_fwd_gets(addr,to_process)
    elif inst=='fwd_getm':
      perform_fwd_getm(addr,to_process,0)
    elif inst=='replace':
      perform_replacement(t[1])
    else:
      assert False, "invalid request = %r" %t[0]    
 

  def perform_replacement(t):
    # check that the tuple is a not an INVALID entry
    assert t[1]!='INVALID',"invalid state in replacement"
    # the current_state should be ready for eviction
    assert current_state=='READY', "invalid current_state in replacement"
    assert t==memory[len(memory)-1],"not a valid tuple for eviction tuple=%r"%t
    if t[1]=='SHARED':
      send(('PutS',t[0]), to=dir_ctrlr)
      send(('inc_msg_cnt', 1), to=monitor_obj)
      current_state='SHARED_INVALID_ACK'
      await(current_state=='INVALID' or current_state=='INVALID_INVALID_ACK')
      output('await passed with current_state %r'%current_state)
      if current_state=='INVALID':
        pass
      elif current_state=='INVALID_INVALID_ACK':
       await(current_state=='INVALID')
    elif t[1] in ['MODIFIED','EXCLUSIVE']:
      if t[1]=='MODIFIED':
        send(('PutM',t[0],t[2]), to=dir_ctrlr)
        current_state='MODIFIED_INVALID_ACK'
      elif t[1]=='EXCLUSIVE':
        send(('PutE',t[0]), to=dir_ctrlr)
        current_state='EXCLUSIVE_INVALID_ACK'
      send(('inc_msg_cnt', 1), to=monitor_obj)
      await(current_state=='INVALID' or current_state=='INVALID_INVALID_ACK' or current_state=='SHARED_INVALID_ACK')
      output('await passed with current_state %r'%current_state)
      if current_state=='INVALID':
        pass
      elif current_state=='INVALID_INVALID_ACK':
       await(current_state=='INVALID')
      elif current_state=='SHARED_INVALID_ACK':
       await(current_state=='INVALID')
    # remove this tuple at the end of replacement processing 
    output('removing t=%r from memory' %t)
    memory.remove(t)
    # assert that the size of cache is less than equal to CACHE_SIZE
    assert len(memory)<=CACHE_SIZE,'cache size corrupted, memory size=%r,CACHE_SIZE_PARAM=%r'%(len(memory),CACHE_SIZE) 
    current_state='READY'
         

  def perform_fwd_getm(addr,to_process,ack):
    output("in perform_fwd_getm begin: %r" %memory)
    res=[x for x in memory if x[0]==addr]
    assert len(res)>0,'address not in memory. Fwd_getM. addr_rvd=%r' %addr
    assert res[0][1]!='INVALID','address in INVALID state Fwd_getS.'
    assert res[0][1]!='SHARED','address in SHARED state Fwd_getS.'
    # handle EXCLUSIVE and MODIFIED both
    # get index of the mem tuple from memory
    # pop that tyuple, insert new tuple at index again, new tuple's state changed to SHARED
    # mem tuple will not be at the head of the LRU
    index=memory.index(res[0])
    t=memory.pop(index)
    if t[1] in ['MODIFIED','EXCLUSIVE']:
      memory.insert(index,(t[0],'INVALID',t[2]))
    elif t[1] in ['MODIFIED_INVALID_ACK','EXCLUSIVE_INVALID_ACK']:
      memory.insert(index,(t[0],'INVALID_INVALID_ACK',t[2]))
      current_state='INVALID_INVALID_ACK'   
    elif t[1]=='OWNER':
      #current_state='INVALID'
      memory.insert(index,(t[0],'INVALID',t[2]))
    elif t[1]=='OWNER_MODIFIED_ACK_COUNT':
      current_state='INVALID_MODIFIED_ACK_DATA'
      memory.insert(index,(t[0],current_state,t[2]))
    elif t[1]=='OWNER_INVALID_ACK':
      memory.insert(index,(t[0],'INVALID_INVALID_ACK',t[2]))
      current_state='INVALID_INVALID_ACK'   
    else:
      memory.insert(index,t)
    
    # send data to req, set state to INVALID
    if res[0][1] in ['OWNER','OWNER_MODIFIED_ACK_COUNT']:
      send(('data_from_dir',ack,res[0][0],res[0][2]),to=to_process)
    else:
      send(('data_from_owner',res[0][0],res[0][2]),to=to_process)
    send(('inc_msg_cnt', 1), to=monitor_obj)
    output("in perform_fwd_getm : %r" %memory)


  def perform_fwd_gets(addr,to_process):
    output("in perform_fwd_getS begin: %r" %memory)
    res=[x for x in memory if x[0]==addr]
    assert len(res)>0,'address not in memory. Fwd_getS. addr_rvd=%r' %addr
    #if res[0][1] in ['EXCLUSIVE','MODIFIED','EXCLUSIVE_INVALID_ACK','MODIFIED_INVALID_ACK']: 
    #  send(('data',res[0][0],res[0][2]),to=dir_ctrlr)
    # get index of the mem tuple from memory
    # pop that tyuple, insert new tuple at index again, new tuple's state changed to SHARED
    # mem tuple will not be at the head of the LRU
    index=memory.index(res[0])
    t=memory.pop(index)
    if t[1]=='MODIFIED':
      memory.insert(index,(t[0],'OWNER',t[2]))
    elif t[1]=='EXCLUSIVE':
      memory.insert(index,(t[0],'SHARED',t[2]))
    elif t[1]=='MODIFIED_INVALID_ACK':
      memory.insert(index,(t[0],'OWNER_INVALID_ACK',t[2]))
      current_state='OWNER_INVALID_ACK'
    elif t[1]=='EXCLUSIVE_INVALID_ACK':
      memory.insert(index,(t[0],'SHARED_INVALID_ACK',t[2]))
      current_state='SHARED_INVALID_ACK'
    #elif t[1] in ['OWNER','OWNER_MODIFIED_ACK_COUNT','OWNER_MODIFIED_ACK','OWNER_INVALID_ACK']:
    else:
      memory.insert(index,t)
  
   # send data to req,
    send(('data_from_owner',res[0][0],res[0][2]),to=to_process)
    send(('inc_msg_cnt', 1), to=monitor_obj)
    output("in perform_fwd_gets : %r" %memory)

  def perform_invalidation(addr,to_process):
    """ Invalidate memory, send Inv_Ack to the caches."""
    # state should be SHARED
    res=[x for x in memory if x[0]==addr ]
    assert len(res) >0, 'addr_rcvd %r not in cache memory.' % addr
    output('invalidate function. addr_rcvd=%r, state=%r'%(addr,res[0][1]))
    send(('Inv_Ack',addr,to_process),to=to_process)
    send(('inc_msg_cnt', 1), to=monitor_obj)
    index=memory.index(res[0])
    t=memory.pop(index)
    if t[1] == 'SHARED':
      memory.insert(index,(t[0],'INVALID',t[2]))
    elif t[1] == 'SHARED_MODIFIED_ACK_DATA':
      memory.insert(index,(t[0],'INVALID_MODIFIED_ACK_DATA',t[2]))
      current_state='INVALID_MODIFIED_ACK_DATA'
    elif t[1] == 'SHARED_INVALID_ACK':
      memory.insert(index,(t[0],'INVALID_INVALID_ACK',t[2]))
      current_state='INVALID_INVALID_ACK'
    else:
      assert False,"invalid state in perform_invalidation"
    output("in perform_inv %r"%memory)


  def perform_load(addr,to_process):
    """ load the value of a particular address in the cache. """
    assert current_state=='READY', "state is not in READY state but in %r" % current_state
    # check state of addr in mem
    # tuple in memory is of the form (addr,status,value)
    res=[x for x in memory if x[0]==addr ]
    if len(res)>0:
      # if addr was present in memory
      assert res[0][0]==addr,"memory should have 'addr' but has %r" % res[0][0]
      if res[0][1]=='INVALID':
        # move this addr to the head of the memory list, update LRU
        update_lru_position_of(res[0])
        # make transition from I to S/E
        current_state='INVALID'
        move_I_to_SorE(addr)
      elif res[0][1] in ['SHARED','MODIFIED','EXCLUSIVE','OWNER']:
        # since state is ANY OF THE ABOVE, update lru and return the value
        update_lru_position_of(res[0])
      else:
        assert False, "invalid state %r" % res[0][2]
    else:
      # addr iis not present in memory
      # add addr to memory.
      # add_to_memory, adds new item to the HEAD of memory list with an INVALID state
      add_to_memory((addr,'INVALID',0))
      current_state='INVALID'
      move_I_to_SorE(addr)
    # requested addr should be at the head of the memory
    assert memory[0][0]==addr, "newly loaded memory invariant failed for addr,state= %r, %r" % (memory[0][0],memory[0][1])
    assert memory[0][1]!='INVALID', "newly loaded memory invariant failed for addr,state= %r, %r" % (memory[0][0],memory[0][1])    
    current_state='READY'
    output("Sending Ack")
    send('completed', to=to_process)
    send(('inc_msg_cnt', 1), to=monitor_obj)
    output("in perform_load %r"%memory)
    output("value returned to processor =%r" % memory[0][2])
    output('after perform_load mem state=%r,lc=%r'%(memory,logical_clock()))
    send(('ins', 'load', addr, memory[0][2], self.id,logical_clock()),to=monitor_obj)
    send(('inc_msg_cnt', 1), to=monitor_obj)

  def perform_store(addr,to_process,data):
    """ store the value of a particular address in the cache. """
    assert current_state=='READY', "state is not in READY state but in %r" % current_state
    #check the state of addr and act accordingly
    res=[x for x in memory if x[0]==addr ]
    if len(res)>0:
      # if address in present in cache
      if res[0][1]=='INVALID':
	# move this addr to the head of the memory list, update LRU
        update_lru_position_of(res[0])
        # make transition from I to M
        current_state='INVALID'
        move_I_to_M(addr,data)
      elif res[0][1]=='SHARED':
	# move to head, update LRU
        update_lru_position_of(res[0])
	# make S to M transition
        current_state='SHARED'
        move_S_to_M(addr,data)
      elif res[0][1] =='MODIFIED':
        update_lru_position_of(res[0])
        # write data to memory
        tx=memory.pop(0)
        memory.insert(0,(tx[0],tx[1],data))
      elif res[0][1] =='OWNER':
        update_lru_position_of(res[0])
        current_state='OWNER'
        move_O_to_M(addr,data)
      elif res[0][1]=='EXCLUSIVE':
        update_lru_position_of(res[0])
        current_state='EXCLUSIVE'
        move_E_to_M(addr,data)
      else:
        assert False,"invalid state %r" %res[0][2]
    else:
      # addr is not in cache
      # add addr in cache
      # add_to_memory, adds new item to the HEAD of memory list with an INVALID state
      add_to_memory((addr,'INVALID',0))
      current_state='INVALID'
      move_I_to_M(addr,data)
    # requested addr should be at the head of the memory
    assert memory[0][0]==addr, "newly loaded memory invariant failed for addr,state= %r, %r" % (memory[0][0],memory[0][1])
    assert memory[0][1]=='MODIFIED', "newly loaded memory invariant failed for addr,state= %r, %r" % (memory[0][0],memory[0][1])    
    current_state='READY'
    output("Sending Ack")
    send('completed', to=to_process)
    output("in perform_store %r"%memory)
    output("value written in cache =%r" % memory[0][2])
    output('after perform_store mem state=%r, lc=%r'%(memory,logical_clock()))
    send(('ins', 'store', addr, memory[0][2], self.id,logical_clock()),to=monitor_obj)
  
  def move_I_to_SorE(addr):
    res=[x for x in memory if x[0]==addr]
    assert len(res)>0,"couldnt find addr in memory"
    assert memory[0][0]==addr,"current addr request should be at he head of memory LRU, but it isn not"
    assert memory[0][1]==current_state,'memory state corrupted'
    # addr_t,state_t,val_t=memory.pop(0)
    # memory.insert(0,(addr_t,'SHARED',val_t))
    # when in INVALID, on load, send getS to DC and goto ISD
    # possible msgs to be recevied: ('exclusive_data_from_dir'),('data_from_dir',ack=0),('data_from_owner')
    current_state='INVALID_SHARED_DATA'
    t=memory.pop(0)
    memory.insert(0,(t[0],current_state,t[2]))
    assert memory[0][0]==addr,"current addr request should be at he head of memory LRU, but it isn not"
    # inform DC
    send(('GetS',addr),to=dir_ctrlr)
    send(('inc_msg_cnt', 1), to=monitor_obj)
    # await till state changes
    await(current_state=='SHARED' or current_state=='EXCLUSIVE')
    assert memory[0][1]!='INVALID_SHARED_DATA','memory state corrupted'
    return
  
  def move_I_to_M(addr,data):
    res=[x for x in memory if x[0]==addr]
    assert len(res)>0,"couldnt find addr in memory"
    assert memory[0][0]==addr,"current addr request should be at he head of memory LRU, but it isn't not"
    assert memory[0][1]==current_state,'memory state corrupted'
    # addr_t,state_t,val_t=memory.pop(0)
    # memory.insert(0,(addr_t,'SHARED',val_t))
    # when in INVALID, on load, send getS to DC and goto ISD
    # possible msgs to be recevied: ('exclusive_data_from_dir'),('data_from_dir',ack=0),('data_from_owner')
    current_state='INVALID_MODIFIED_ACK_DATA'
    t=memory.pop(0)
    memory.insert(0,(t[0],current_state,t[2]))
    # inform DC
    send(('GetM',addr),to=dir_ctrlr)
    send(('inc_msg_cnt', 1), to=monitor_obj)
    # await till state changes
    move_IMAD_to_M(addr,data)
    t=memory.pop(0)
    assert t[1]==current_state,'memory state corrupted. ItoM'
    memory.insert(0,(t[0],current_state,data))


  def move_IMAD_to_M(addr,data):
    await(current_state=='INVALID_MODIFIED_ACK' or current_state=='MODIFIED')
    assert memory[0][1]!='INVALID_MODIFIED_ACK_DATA','memory state corrupted'
    if current_state=='MODIFIED':
      pass
    else:
      # in IMA state, wait till modified state(receive all acks)
      await(current_state=='MODIFIED')
    return

  def move_O_to_M(addr,data):
    res=[x for x in memory if x[0]==addr]
    assert len(res)>0,"couldnt find addr in memory, OtoM"
    assert memory[0][0]==addr,"current addr request should be at the head of memory LRU, but it isn't not, OtoM"
    assert memory[0][1]==current_state,'memory state corrupted, OtoM'
    current_state='OWNER_MODIFIED_ACK_COUNT'
    t=memory.pop(0)
    memory.insert(0,(t[0],current_state,t[2]))
    # inform DC
    send(('GetM',addr),to=dir_ctrlr)
    send(('inc_msg_cnt', 1), to=monitor_obj)
    # await till state changes
    await(current_state=='OWNER_MODIFIED_ACK' or current_state=='MODIFIED' or current_state=='INVALID_MODIFIED_ACK_DATA')
    # output('await passed, addr_rcvd=%r,state=%r'%(addr,current_state))
    assert memory[0][1]!='OWNER_MODIFIED_ACK_COUNT','memory state corrupted, OtoM'
    if current_state=='MODIFIED':
      # do nothing
      pass
    elif current_state=='OWNER_MODIFIED_ACK':
      # in SMA state, wait till modified state(receive all acks)
      await(current_state=='MODIFIED')
    elif current_state=='INVALID_MODIFIED_ACK_DATA':
      move_IMAD_to_M(addr,data)
    else:
      assert False,'invalid state=%r in O to M' % current_state
    # write data
    # output(memory[0])
    t=memory.pop(0)
    assert t[1]==current_state,'memory state corrupted. OtoM'
    memory.insert(0,(t[0],current_state,data))
    current_state='READY'


  def move_S_to_M(addr,data):
    res=[x for x in memory if x[0]==addr]
    assert len(res)>0,"couldnt find addr in memory"
    assert memory[0][0]==addr,"current addr request should be at he head of memory LRU, but it isn't not"
    assert memory[0][1]==current_state,'memory state corrupted'
    current_state='SHARED_MODIFIED_ACK_DATA'
    t=memory.pop(0)
    memory.insert(0,(t[0],current_state,t[2]))
    # inform DC
    send(('GetM',addr),to=dir_ctrlr)
    send(('inc_msg_cnt', 1), to=monitor_obj)
    # await till state changes
    await(current_state=='SHARED_MODIFIED_ACK' or current_state=='MODIFIED' or current_state=='INVALID_MODIFIED_ACK_DATA')
    # output('await passed, addr_rcvd=%r,state=%r'%(addr,current_state))
    assert memory[0][1]!='SHARED_MODIFIED_ACK_DATA','memory state corrupted'
    if current_state=='MODIFIED':
      # do nothing
      pass
    elif current_state=='SHARED_MODIFIED_ACK':
      # in SMA state, wait till modified state(receive all acks)
      # output('SMA in')
      await(current_state=='MODIFIED')
      # output('SMA out')
    elif current_state=='INVALID_MODIFIED_ACK_DATA':
      move_IMAD_to_M(addr,data)
    else:
      assert False,'invalid state=%r in S to M' % current_state
    # write data
    # output(memory[0])
    t=memory.pop(0)
    assert t[1]==current_state,'memory state corrupted. StoM'
    memory.insert(0,(t[0],current_state,data))
    current_state='READY'

  def move_E_to_M(addr,data):
    # goto MODIFIED state. no other actions
    res=[x for x in memory if x[0]==addr]
    assert len(res)>0,"couldnt find addr in memory"
    assert memory[0][0]==addr,"current addr request should be at he head of memory LRU, but it isn't not"
    assert memory[0][1]==current_state,'memory state corrupted'
    current_state='MODIFIED'
    t=memory.pop(0)
    memory.insert(0,(t[0],current_state,data))
    return
  


  def add_to_memory(t):
    """ add tuple t to the head of memory list. format of tuple t = (address,state,value) """
    # check size of memory, if >= CACHE_SIZE, pop the last element and add the new tuple at the head
    # otherwise, insert at head directly
    if len(memory) >= CACHE_SIZE:
      popped=memory[len(memory)-1]
      # if state of popped is SHARED, MODIFIED, EXCLUSIVE
      if popped[1] in ['SHARED', 'MODIFIED', 'EXCLUSIVE']:
        # queue it at the head of pending request so that it will be the next instruction to be executed
        # any message requesting action on the evicted addr will be added to the end of the pending_actions queue,
        # so write back/replacement will happen before the we get to that previously mentioned message on that addr.
        pending_actions.insert(0,('replace',popped,None))
      else:
        # if state is INVALID, just remove the item from the memory(already done with pop), no action needed
        assert popped[1]=='INVALID', "state corrupted for memory item  %r" % popped
    # add tuple t to the head of og the memory list
    memory.insert(0,t)
    

  def update_lru_position_of(t):
    """ move tuple t to the head of the memory list. t=(address,state,value) """
    # t should be present int the memory list
    assert t in memory, "tuple %r should exist in memory"
    memory.remove(t)
    memory.insert(0,t)

# STATES : message handlers written
# INVALID_SHARED_DATA : 
# to_handle(exclusive_data_from_dir, data_from_dir, data_from_owner)
# stall(invalidate,replacement)
  

  def receive(msg=('exclusive_data_from_dir',addr,val_rvd), from_=s):
#     print ("addr rcvd=%r   addr required=%r" %(addr,memory[0][0]))
#     print("state=%r  mem state=%r" %(current_state,memory[0][1]))
    if current_state=='INVALID_SHARED_DATA' and addr==memory[0][0]:
      # move to EXCLUSIVE state, update the state in memory for the address
      current_state='EXCLUSIVE'
      t=memory.pop(0)
      memory.insert(0,(t[0],current_state,val_rvd))
      assert t[1]=='INVALID_SHARED_DATA','memory state corrupted'
    else:
      assert False, "received out-of-state message. Should not happen. exclusive_data_from_dir.current_state=%r, addr_rcvd=%r, mem0_addr=%r,val_rcvd=%r" % (current_state,addr,memory[0][0],val_rvd)


  def receive(msg=('ackcount_from_dir',ack,addr), from_=s):
    res = [ x for x in memory if x[0]==addr]
#    output("%r in ackcount_from_dir" %res[0])
    assert len(res)>0,"couldnt find addr in memory"
    assert memory[0][0]==addr,"current addr request should be at he head of memory LRU, but it isn't not, ackcount_from_dir"
    assert res[0][1]==current_state,"memory state corrupted, current_state : %r and res[0][0] : %r" %(current_state,res[0][0])
    if current_state=='OWNER_MODIFIED_ACK_COUNT':
      current_state='OWNER_MODIFIED_ACK'
      t=memory.pop(0)
      memory.insert(0,(t[0],current_state,t[2],ack))
    else:
      assert False,'not a valid state for ackcount_from_dir : %r and mem : %r'%(current_state,res[0])

  def receive(msg=('data_from_dir',ack,addr,val_rvd), from_=s):
    if current_state=='INVALID_SHARED_DATA' and addr==memory[0][0] and ack==0:
      # move to SHARED state
      current_state='SHARED'
      t=memory.pop(0)
      memory.insert(0,(t[0],current_state,val_rvd))
    elif current_state=='INVALID_MODIFIED_ACK_DATA' and addr==memory[0][0] and ack==0:
      # move to MODIFIED state
      current_state='MODIFIED'
      t=memory.pop(0)
      memory.insert(0,(t[0],current_state,val_rvd))
      assert t[1]=='INVALID_MODIFIED_ACK_DATA','memory state corrupted. data_from_dir.  IMAD'
    elif current_state=='INVALID_MODIFIED_ACK_DATA' and addr==memory[0][0] and ack>0:
      # move to INVALID_MODIFIED_ACK state
      current_state='INVALID_MODIFIED_ACK'
      t=memory.pop(0)
      memory.insert(0,(t[0],current_state,val_rvd,ack))
      assert t[1]=='INVALID_MODIFIED_ACK_DATA','memory state corrupted.data_from_dir. IMA'
    elif current_state=='SHARED_MODIFIED_ACK_DATA' and addr==memory[0][0] and ack==0:
      # move to MODIFIED state
      current_state='MODIFIED'
      t=memory.pop(0)
      memory.insert(0,(t[0],current_state,val_rvd))
      assert t[1]=='SHARED_MODIFIED_ACK_DATA','memory state corrupted. data_from_dir.  SMAD'
    elif current_state=='SHARED_MODIFIED_ACK_DATA' and addr==memory[0][0] and ack>0:
      # move to SHARED_MODIFIED_ACK state
      current_state='SHARED_MODIFIED_ACK'
      t=memory.pop(0)
      memory.insert(0,(t[0],current_state,val_rvd,ack))
      assert t[1]=='SHARED_MODIFIED_ACK_DATA','memory state corrupted.data_from_dir. SMA'
    else:
      assert False, "received out-of-state message. Should not happen. data_from_dir. CURRENT_STATE=%r,ack_count=%r, addr rcvd=%r" % (current_state,ack,addr)

  def receive(msg=('data_from_owner',addr,val_rvd), from_=s):
    if current_state=='INVALID_SHARED_DATA' and addr==memory[0][0]:
      # move to SHARED state
      current_state='SHARED'
      t=memory.pop(0)
      memory.insert(0,(t[0],current_state,val_rvd))
      assert t[1]=='INVALID_SHARED_DATA','memory state corrupted.data_from_owner.ISD'
    elif current_state=='INVALID_MODIFIED_ACK_DATA' and addr==memory[0][0]:
      # move to MODIFIED state
      current_state='MODIFIED'
      t=memory.pop(0)
      memory.insert(0,(t[0],current_state,val_rvd))
      assert t[1]=='INVALID_MODIFIED_ACK_DATA','memory state corrupted. data_from_owner. IMAD'
    elif current_state=='SHARED_MODIFIED_ACK_DATA' and addr==memory[0][0]:
      # move to MODIFIED state
      current_state='MODIFIED'
      t=memory.pop(0)
      memory.insert(0,(t[0],current_state,val_rvd))
      assert t[1]=='SHARED_MODIFIED_ACK_DATA','memory state corrupted. data_from_owner. SMAD'
    else:
      assert False, "received out-of-state message. Should not happen. data_from_owner. current_state %r, addr %r" %(current_state,addr)

  def receive(msg=('Put_Ack',addr,p), from_=s):
    res = [ x for x in memory if x==addr]
    assert len(res)>0, "addr not in cache memory %r" %addr
    assert res[1]!='INVALID', "memory state not valid for put-ack"

    if current_state in ['SHARED_INVALID_ACK','INVALID_INVALID_ACK','MODIFIED_INVALID_ACK','EXCLUSIVE_INVALID_ACK','OWNER_INVALID_ACK']:
      index=memory.index(res[0])
      t=memory.pop(index)
      memory.insert(index,(t[0],'INVALID',t[2]))
      current_state='INVALID'
    else:
      assert False,'invalid state for handling put-ack.'

  
  def receive(msg=('Inv_Ack',addr,p), from_=s):
    # state has to be in INVALID_MODIFIED_ACK
    # output('inv-ack')
    if current_state=='INVALID_MODIFIED_ACK' and addr==memory[0][0]:
      t=memory.pop(0)
      # output('addr_rcvd=%r, ack_count=%r'%(addr,t[3]))
      assert type(t[3]) is int, 'ack_count corrupted'
      assert t[3] >0,'ack count corrupted <=0'
      ack_cnt=t[3]
      ack_cnt-=1      
      if ack_cnt==0:
        current_state='MODIFIED'
      memory.insert(0,(t[0],current_state,t[1],ack_cnt))
    elif current_state=='INVALID_MODIFIED_ACK_DATA' and addr==memory[0][0]:
      ## can occur in the case where cache entry is in S/I->M state and directory is in O->M state.
      # wait till date from owner (faked data_from_dir is arrived, which tells us ack_cnt) 
      await(current_state=='INVALID_MODIFIED_ACK')
      t=memory.pop(0)
      assert type(t[3]) is int, 'ack_count corrupted'
      assert t[3]>0,'ack count corrupted <=0'
      ack_cnt=t[3]
      ack_cnt-=1      
      if ack_cnt==0:
        current_state='MODIFIED'
      memory.insert(0,(t[0],current_state,t[1],ack_cnt))
    
    elif current_state=='SHARED_MODIFIED_ACK' and addr==memory[0][0]:
      t=memory.pop(0)
      # output('INV_ACK addr_rcvd=%r, ack_count=%r'%(addr,t[3]))
      assert type(t[3]) is int, 'ack_count corrupted'
      assert t[3] >0,'ack count corrupted <=0'
      ack_cnt=t[3]
      ack_cnt-=1
      if ack_cnt==0:
        current_state='MODIFIED'
      memory.insert(0,(t[0],current_state,t[2],ack_cnt))
    elif current_state=='SHARED_MODIFIED_ACK_DATA' and addr==memory[0][0]:
      assert False,'received inv ack when in SMAD state'
    elif current_state=='OWNER_MODIFIED_ACK' and addr==memory[0][0]:
      t=memory.pop(0)
      # output('INV_ACK addr_rcvd=%r, ack_count=%r'%(addr,t[3]))
      assert type(t[3]) is int, 'ack_count corrupted, OMA'
      assert t[3]>0,'ack count corrupted <=0'
      ack_cnt=t[3]
      ack_cnt-=1
      if ack_cnt==0:
        current_state='MODIFIED'
      memory.insert(0,(t[0],current_state,t[2],ack_cnt))
    elif current_state=='OWNER_MODIFIED_ACK_COUNT' and addr==memory[0][0]:
      assert False,'received inv ack when in OMAC state'
    else:
      assert False,'received out-of-state message. Should not happen. Inv-ACK. addr_rcvd=%r, head_memory=%r, state=%r'%(addr,memory[0],memory[0][1])


  def receive(msg=('Inv',addr,p), from_=s):
    # handled for I,ISD,IMAD,IMA
    res=[x for x in memory if x[0]==addr]
    assert len(res)>0,'addr_rcvd=%r not in memory'%addr
    # output('inv msg rcvd for address=%r, state=%r'%(addr,res[0][1]))
    if(res[0][1]=='SHARED'):
      perform_invalidation(addr,p)
    elif(res[0][1]=='SHARED_MODIFIED_ACK_DATA'):
      perform_invalidation(addr,p)
    # handle SIA
    elif(res[0][1]=='SHARED_INVALID_ACK'):
      perform_invalidation(addr,p)
    else:
      pending_actions.append(('inv',addr,p))
    

  def receive(msg=('Fwd_GetS',addr,p), from_=s):
    # handled for I,ISD,IMAD,IMA
    res=[x for x in memory if x[0]==addr]
    if res[0][1] in ['EXCLUSIVE','MODIFIED','EXCLUSIVE_INVALID_ACK','MODIFIED_INVALID_ACK','OWNER','OWNER_MODIFIED_ACK_COUNT','OWNER_MODIFIED_ACK']:
      perform_fwd_gets(addr,p)
    else:
      pending_actions.append(('fwd_gets',addr,p))

  def receive(msg=('Fwd_GetM',addr,p), from_=s):
    # handled for I,ISD,IMAD,IMA
    res=[x for x in memory if x[0]==addr]
    if res[0][1] in ['EXCLUSIVE','MODIFIED','EXCLUSIVE_INVALID_ACK','MODIFIED_INVALID_ACK','OWNER_MODIFIED_ACK_COUNT']:
      perform_fwd_getm(addr,p,0)
    else:
      pending_actions.append(('fwd_getm',addr,p))

  def receive(msg=('Fwd_GetM',addr,p,ack), from_=s):
    # handled for I,ISD,IMAD,IMA
    res=[x for x in memory if x[0]==addr]
    if res[0][1] in ['OWNER','OWNER_MODIFIED_ACK_COUNT']:
      perform_fwd_getm(addr,p,ack)


  def receive(msg=('load',addr, p), from_=s):
    self.pending_actions.append(('load',addr, s))
    output("Received LOAD request for addr %s" % addr)
 
  def receive(msg=('store',addr, p, data), from_=s):
    self.pending_actions.append(('store',addr, s, data))
    output("Received STORE request for addr %s" % addr);
 
  def receive(msg= ('done',)):
    print("Cache Exiting\n")
    exit()

class MI_PROTO_CTRL(process):
  def setup(cache_protocol_objs,monitor_obj):
    self.pending_actions=[]
    self.memory = dict()
    memory['0x11111114']=['INVALID',None,[],212]

  def run():
    while(1):
      await(len(self.pending_actions)>0)
      #queue has some pending request and  state is READY
      #process request
      processRequest()

  
  def processRequest():
    # deque request
    t=pending_actions.pop(0)
    #possible instructions are : loads,stores, invlalidate
    # pending_actions tuple format : (inst,addr,to_process,data)
    # check if addr is in memory, else add it to memory with INVALID state
    if(t[1] not in memory):
      memory[t[1]]=['INVALID',self.id,[],555]

    if(t[0]=='GetS'):
      perform_getS(t[1],t[2])
    elif(t[0]=='GetM'):
      perform_getM(t[1],t[2])
    elif(t[0]=='PutS'):
      perform_putS(t[1],t[2])
    elif(t[0]=='PutM'):
      perform_putM(t[1],t[2],t[3])
    elif(t[0]=='PutE'):
      perform_putE(t[1],t[2])
    elif(t[0]=='PutO'):
      perform_putO(t[1],t[2],t[3])
    else:
      assert False,'invalid request in pending actions queue'



  def perform_putS(addr,to_process):
    # remove req from sharers, send Put-Ack to req, if no sharer after removing this, 
    # go to INVALID state, therwise S->S.
    assert to_process in memory[addr][2],'to_process not in sharers list'
    memory[addr][2].remove(to_process)
    if(len(memory[addr][2])==0):
      memory[addr][0]='INVALID'
    send(('Put_Ack',addr,self.id),to=to_process)
    send(('inc_msg_cnt', 1), to=monitor_obj)

  def perform_putO(addr,to_process,data):
    assert memory[addr]=='OWNER','memory state corrupted, perform_putO'
    # copy data to memory
    # send put-ack to req
    # clear owner
    # make state INVALID if no sharers OR  SHARED is sharers are there
    memory[addr][3]=data
    memory[addr][1]=None
    if len(memory[addr][2])>0:
      memory[addr][0]='SHARED'
    else:
      memory[addr][0]='INVALID'
    send(('Put_Ack',addr,self.id),to=to_process)
    send(('inc_msg_cnt', 1), to=monitor_obj)

  def perform_putM(addr,to_process,data):
    assert memory[addr]=='MODIFIED','memory state corrupted, perform_putM'
    time.sleep(0.1)
    # copy data to memorry
    # send put-ack to req
    # clear owner
    # make state INVALID
    memory[addr][3]=data
    memory[addr][1]=None
    memory[addr][0]='INVALID'
    send(('Put_Ack',addr,self.id),to=to_process)
    send(('inc_msg_cnt', 1), to=monitor_obj)

  def perform_putE(addr,to_process):
    assert memory[addr]=='EXCLUSIVE','memory state corrupted'
    # send put-ack to req
    # clear owner
    # make state INVALID
    memory[addr][1]=None
    memory[addr][0]='INVALID'
    send(('Put_Ack',addr,self.id),to=to_process)
    send(('inc_msg_cnt', 1), to=monitor_obj) 

  def perform_getS(addr,to_process):
    # key -value : memory_addr, [state,owner,[sharers],value]
    assert addr in memory, "address %r not in memory" % addr
    if memory[addr][0]=='INVALID':
      time.sleep(0.1)
      # send exclusive data to req, set owner to req, set state to exclusive
      send(('exclusive_data_from_dir',addr,memory[addr][3]),to=to_process)
      memory[addr][1]=to_process
      memory[addr][0]="EXCLUSIVE"
    elif memory[addr][0]=='SHARED':
      # send data to req with ack=0, add req to sharers list, no change to state
      memory[addr][2].append(to_process)
      send(('data_from_dir',0,addr,memory[addr][3]),to=to_process)
    elif memory[addr][0]=='EXCLUSIVE':
      # forward GetS to owner, add req to sharers
      # make state as OWNER
      send(('Fwd_GetS',addr,to_process),to=memory[addr][1])
      memory[addr][2].append(to_process)
      memory[addr][2].append(memory[addr][1])
      memory[addr][0]='SHARED'
      memory[addr][1]=[]
      # await for data from the exclusive owner ???
      #await(memory[addr][0]=='SHARED')
    elif memory[addr][0]=='MODIFIED':
      # forward getS to owner, 
      # add req to sharers, make state as OWNER
      send(('Fwd_GetS',addr,to_process),to=memory[addr][1])
      memory[addr][2].append(to_process)
      memory[addr][0]='OWNER'
    elif memory[addr][0]=='OWNER':
      # forward getS to owner,
      # add req to sharers, 
      send(('Fwd_GetS',addr,to_process),to=memory[addr][1])
      memory[addr][2].append(to_process)
    else:
      assert False, 'invalid memory state. getS'
  send(('inc_msg_cnt', 1), to=monitor_obj)


  def perform_getM(addr,to_process):
    # key -value : memory_addr, [state,owner,[sharers],value]
    assert addr in memory, "address %r not in memory, current memory state %r " % (addr,memory[addr][0]) 
    output("addr_rcvd=%r, state in memory=%r"%(addr,memory[addr][0]))
    if memory[addr][0]=='INVALID':
      # send data_from_dir with ack=0 to req, set owner to req, set state MODIFIED
      time.sleep(0.1)
      send(('data_from_dir',0,addr,memory[addr][3]),to=to_process)
      send(('inc_msg_cnt', 1), to=monitor_obj)
      memory[addr][1]=to_process
      memory[addr][0]="MODIFIED"
    elif memory[addr][0]=='SHARED':
      # send data to req with ack>0,send INV to sharers
      # clear shareers, set owner to request, set state to MODIFIED
      # check if req is part of the sharers list
      # if so, remove to_process from sharers list      
      if to_process in memory[addr][2]:
        memory[addr][2].remove(to_process)
      send(('data_from_dir',len(memory[addr][2]),addr,memory[addr][3]),to=to_process)
      send(('inc_msg_cnt', 1), to=monitor_obj)
      output('%r sending inv message to %r (in SHARED)'%(to_process,memory[addr][2]))
      send(('Inv',addr,to_process),to={x for x in memory[addr][2]})
      send(('inc_msg_cnt', len(memory[addr][2])), to=monitor_obj)
      memory[addr][2]=[]
      memory[addr][1]=to_process
      memory[addr][0]='MODIFIED'
    elif memory[addr][0]=='EXCLUSIVE':
      # forrward getM to owner, set owner to req
      # change state to MODIFIED
      send(('Fwd_GetM',addr,to_process),to=memory[addr][1])
      send(('inc_msg_cnt', 1), to=monitor_obj)
      memory[addr][1]=to_process
      memory[addr][0]='MODIFIED'
    elif memory[addr][0]=='MODIFIED':
      # forward getM to owner, set owner to req
      send(('Fwd_GetM',addr,to_process),to=memory[addr][1])
      send(('inc_msg_cnt', 1), to=monitor_obj)
      memory[addr][1]=to_process
    elif memory[addr][0]=='OWNER':
      #in case owner is the requester
        # send ackcount to req, send inv to sharers,
        # clear sharers, set state to MODIFIED
      #else (in case owner is not the requester)
        # fwd-getm to owner, send inv to sharers,
        # set owner to req, clear sharers, send ackcount to req, set state to MODIFIED
      if to_process!=memory[addr][1]:
        if to_process in memory[addr][2]:
          memory[addr][2].remove(to_process)
        send(('Fwd_GetM',addr,to_process,len(memory[addr][2])),to=memory[addr][1])
        send(('inc_msg_cnt', 1), to=monitor_obj)
        memory[addr][1]=to_process
      elif to_process==memory[addr][1]:
        send(('ackcount_from_dir',len(memory[addr][2]),addr),to=to_process)
        send(('inc_msg_cnt', 1), to=monitor_obj)
      output('%r sending inv message to %r (in OWNER)'%(to_process,memory[addr][2]))
      send(('Inv',addr,to_process),to={x for x in memory[addr][2]})
      send(('inc_msg_cnt', len(memory[addr][2])), to=monitor_obj)
      memory[addr][2]=[]
      memory[addr][0]='MODIFIED'
    else:
      assert False, 'invalid memory state for addr_rcvd=%r,state in memory=%r'%(addr,memory[addr][0])


  def receive(msg=('GetS',addr), from_=p):
    """ Put it in pending queue"""
    pending_actions.append(('GetS',addr,p))

  def receive(msg= ('GetM',addr), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('GetM',addr,p))

  def receive(msg= ('PutS',addr), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('PutS',addr,p))

  def receive(msg= ('PutM',addr,data), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('PutM',addr,p,data))

  def receive(msg= ('PutE',addr), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('PutE',addr,p))

  def receive(msg= ('PutO',addr,data), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('PutO',addr,p,data))



  # not required in MOESI protocol
  def receive(msg= ('data',addr,data), from_= p):
    """ Do not queue"""
    # receiveing data, that means, addr should be in memory
    assert addr in memory, "addr=%r not present in DC memory" % addr
    #assert current_state=='SHARED_DATA','invalid data received'
    # key -value : memory_addr, [state,owner,[sharers],value]
    assert memory[addr][0]=='SHARED_DATA','invalid memory state, data received'
    # update value, update state to 'SHARED'
    memory[addr][3]=data
    memory[addr][0]='SHARED'


  def receive(msg= ('done',)):
    print("CTRL Exiting\n")
    exit()

class Processor(process):
    def setup(trace, protocol,monitor_obj):
      self.keep_waiting = False
      ## self.cache = Cache(protocol, CACHE_SIZE)
    
    def execute(inst):
      if inst[0] == "r":
        send(('load',inst[1] , self.id), to=protocol)
        send(('inc_msg_cnt', 1), to=monitor_obj)

      elif inst[0] == "w":
        send(('store', inst[1], self.id, inst[2]), to=protocol)
        send(('inc_msg_cnt', 1), to=monitor_obj) 
      else:
        print("Unexpected instruction:", inst);
    
    def run():
      for inst in trace:
        keep_waiting = False
        execute(inst)
        await(keep_waiting)

      print("Processor Exits")

    def receive(msg= ('completed')):
      print("ACKed\n")
      keep_waiting = True

def get_traces(trace_dir, nprocs):
  trace=[]
  for i in range(nprocs):
    trace_filename='p'+str(i)+'.trace'
    f=open(os.path.join(trace_dir,trace_filename))
    insts=[]
    for line in f:
      insts.append(line.split())
    trace.append(insts)
  return trace  

class Monitor(process):
  def setup():
    self.instructions = []
    self.total_msgs = 0
    self.cpu_time = 0
    self.elapsed_time = 0
   
  def receive(msg= ('ins', type, addr, value, cache_id,lc)):
    instructions.append((type, addr, value, cache_id,lc))

  def receive(msg= ('inc_msg_cnt', value)):
    total_msgs = total_msgs + value

  def receive(msg= ('time_taken', cpu, elapsed)):
    cpu_time = cpu
    elapsed_time = elapsed 

  def run():
    await(False)
    
  def receive(msg= ('done',)):
    print("===Load/Store global order===")
    for ins in instructions:
      print(ins[3], " : ", ins[0], ins[1], ins[2])
    print()
    print("===Benchmarks===")
    print("Total msg count:", total_msgs)
    print("Elapsed time:", elapsed_time)
    print("CPU time:", cpu_time)
    exit()

def main():
    nprocessors = int(sys.argv[1]) if len(sys.argv) > 1 else 2
    proto_name = sys.argv[2] if len(sys.argv) > 2 else 'MI'
    #trace_file = sys.argv[3] if len(sys.argv) > 3 else exit(-1)
    trace_dir = sys.argv[3] if len(sys.argv) > 3 else './traces'

    config(channel= 'fifo', clock= 'Lamport')
    
    start_cpu_time = time.process_time()
    start_elapsed_time = time.perf_counter()
    
    trace = get_traces(trace_dir,nprocessors)
    print(trace)
    Proto_cache, Proto_ctrl = get_proto_class(proto_name)
    
    print('-----START-----')
    ## Start monitor process
    monitor_obj = new(Monitor, num=1)
    setup(monitor_obj, ())
    start(monitor_obj)

    
    ## Initialize protocol objs for caches and controller
    mem_ctrl_protocol_obj = new(Proto_ctrl, num=1)
    protocol_objs = new(Proto_cache, num=nprocessors)
    
    ## Setup Protocol for ctrller
    setup(mem_ctrl_protocol_obj, (protocol_objs,monitor_obj))
    start(mem_ctrl_protocol_obj)

    ## Setup Protocols for caches
    for proto_obj in protocol_objs:
      setup(proto_obj, (mem_ctrl_protocol_obj, protocol_objs - {proto_obj}, CACHE_SIZE,monitor_obj))
      start(proto_obj)

    ## Setup Processors
    processors = new(Processor, num= nprocessors)
    
    ## temp lists for iterating
    processors_list = list(processors)
    protocol_objs_list = list(protocol_objs)
    for i in range(nprocessors): 
      setup(processors_list[i], (trace[i], protocol_objs_list[i],monitor_obj))
    
    start(processors)
    
    ## Exiting logic  
    for p in processors: 
      p.join()

    da.send(('done',), to= protocol_objs)
    for m in protocol_objs:
      m.join()

    da.send(('done',), to= mem_ctrl_protocol_obj)
    for m in mem_ctrl_protocol_obj:
      m.join()

    end_cpu_time = time.process_time()
    end_elapsed_time = time.perf_counter()

    da.send(('time_taken', end_cpu_time-start_cpu_time, end_elapsed_time-start_elapsed_time), to= monitor_obj)
    da.send(('done',), to= monitor_obj)
    for monitor in monitor_obj:
      monitor.join()
    print('-----END-----')

