import sys
import time
import os

ENOTSUPP = 2
CACHE_SIZE = 512

class MOSI_PROTO_CTRL(process):
  def setup(cache_protocol_objs):
    self.pending_actions=[]
    self.directory_ctrlr = dict()
    directory_ctrlr['0x11111114']=['INVALID',None,[],212]

  def run():
    while(1):
      # wait till you receive a request 
      await(len(self.pending_actions) > 0)
      # process the received request
      processRequest()


  # check and process the request  
  def processRequest():
    # dequeue request
    action = pending_actions.pop(0)
    instruction = action[0]
    block_addr = action[1]
    cache = action[2]

    # pending_actions tuple format : (instruction, block_addr, cache, data)
    # check if block address is in the memory
    # if not put the address in the memory with INVALID state
    # and add the processor cache_id 
    if(block_addr not in directory_ctrlr):
      directory_ctrlr[block_addr]=['INVALID',self.id,[],555]

    if(instruction == 'GetS'):
      # get the block address for read operation
      getS(cache, block_addr)
    elif(instruction == 'GetM'):
      # get the block address for write operation
      getM(cache, block_addr)
    elif(instruction=='PutS'):
      putS(block_addr, cache)
    elif(instruction=='PutM'):
      putM(block_addr, cache, action[3])
    elif(instruction=='PutE'):
      putO(block_addr, cache)
    else: 
      print('Invalid request')



  # Get the block address for reading
  def getS(cache, block_addr):

    #get the state of the block in the directory controller
    tuple = directory_ctrlr[block_addr];
    state = tuple[0];

    #check the state and correspond to other caches accordingly
    if(state == "INVALID"):
      state = "SHARED"
      directory_ctrlr[block_addr][2].append(cache)
      send(("data_from_DC", 0, block_addr, tuple[3]), to=cache)
    elif(state == "SHARED"):
      directory_ctrlr[block_addr][2].append(cache)
      send(("data_from_DC", 0, block_addr, tuple[3]), to=cache)
    elif(state == "MODIFIED"):
      state = "OWNED"
      directory_ctrlr[block_addr][2].append(cache)
      send(("Fwd_GetS", cache, block_addr), to=directory_ctrlr[block_addr][1])
    elif(state == "OWNED"):
      directory_ctrlr[block_addr][2].append(cache)
      send(("Fwd_GetS", cache, block_addr), to=directory_ctrlr[block_addr][1])
    else:
      print('DC: State not supported!')

    directory_ctrlr[block_addr][0] = state; 


  # get the block address for writing
  def getM(cache, block_addr):
    
    #get the state of the block in the directory controller
    tuple = directory_ctrlr[block_addr];
    state = tuple[0];
    data = tuple[3]

    ack_count = 0

    if (state == "INVALID"):
      send(('data_from_DC', 0, block_addr, data), to= cache);
      directory_ctrlr[block_addr][1] = cache
      directory_ctrlr[block_addr][2] = [] 
	
    elif(state == "SHARED"):
      if cache in directory_ctrlr[block_addr][2]:
        directory_ctrlr[block_addr][2].remove(cache)

      ack_count = len(directory_ctrlr[block_addr][2])
      send(('data_from_DC', ack_count, block_addr, data), to=cache)
      send(('Invalidate', cache, block_addr),to={x for x in directory_ctrlr[block_addr][2]})
      directory_ctrlr[block_addr][1] = cache
      directory_ctrlr[block_addr][2] = []
 
    elif(state == "MODIFIED"):
      send(('Fwd_GetM', cache, block_addr, 0), to= directory_ctrlr[block_addr][1]);
      directory_ctrlr[block_addr][1] = cache

    elif (state == "OWNED"):
      ack_count = len(directory_ctrlr[block_addr][2])
      if ( cache == directory_ctrlr[block_addr][1]):
        send(('Ack_cnt', ack_count, block_addr), to=cache)
        send(('Invalidate', cache, block_addr),to={x for x in directory_ctrlr[block_addr][2]})
      else:
        send(('Ack_cnt', ack_count, block_addr), to=cache)
        send(('Fwd_getM', cache, block_addr, ack_count), to= directory_ctrlr[block_addr][1]);
        send(('Invalidate', cache, block_addr),to={x for x in directory_ctrlr[block_addr][2]})
        directory_ctrlr[block_addr][1] = cache 
      directory_ctrlr[block_addr][2] = []
    else:
      print("DC_getM: State not supported!")

    directory_ctrlr[block_addr][0] = "MODIFIED"


  def putS(addr, proc):
    directory_ctrlr[addr][2].remove(proc)
    if(len(directory_ctrlr[addr][2])==0):
      directory_ctrlr[addr][0]='INVALID'
    send(('Put_Ack',addr,self.id),to=proc)

  def putM(addr,proc,data):
    directory_ctrlr[addr][3]=data
    directory_ctrlr[addr][1]=None
    directory_ctrlr[addr][0]='INVALID'
    send(('Put_Ack',addr,self.id),to=proc)

  def putO(addr,proc,data):
    directory_ctrlr[addr][3]=data
    directory_ctrlr[addr][1]=None
    if len(directory_ctrlr[addr][2])>0:
      directory_ctrlr[addr][0]='SHARED'
    else:
      directory_ctrlr[addr][0]='INVALID'
    send(('Put_Ack',addr,self.id),to=proc)


  def receive(msg=('GetS',addr), from_=p):
    """ Put it in pending queue"""
    pending_actions.append(('GetS',addr,p))

  def receive(msg= ('GetM',addr), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('GetM',addr,p))

  def receive(msg= ('PutS',addr), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('PutS',addr,p))

  def receive(msg= ('PutM',addr,data), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('PutM',addr,p,data))

  def receive(msg= ('PutO',addr), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('PutO',addr,p))

  def receive(msg= ('data',addr,data), from_= p):
    directory_ctrlr[addr][3]=data
    directory_ctrlr[addr][0]='SHARED'

  def receive(msg= ('done',)):
    print("CTRL Exiting\n")
    exit()


def get_proto_class(name):
  if name == "MOSI":
   return (eval("MOSI_PROTO_CACHE"), eval("MOSI_PROTO_CTRL"))
  else:
   exit((-ENOTSUPP))


## Exemplary implementation of PROTOCOL Classes
"""
  MOSI Protocol class:
"""
class MOSI_PROTO_CACHE(process):
  def setup(DC, other_caches, size):
    self.local_cache = []

    self.pending_actions=[]
    self.current_state="READY"

  def run():
    while(1):
      await(len(self.pending_actions)>0 and current_state == 'READY')
      # queue has some pending request and  state is READY
      # process request
      print('ready state ------', pending_actions)
      processRequest()

  def processRequest():
    # deque request
    # (instruction, block_addr, p, data)
    action = pending_actions.pop(0)
    instruction = action[0] if len(action) > 0 else ''
    block_addr = action[1]  if len(action) > 1 else ''
    p = action[2] if len(action) > 2 else ''
    data = action[3] if len(action) > 3 else ''


    # Instruction: LOAD, STORE or INVALIDATE
    # Might need to forward the request to the other caches
    # based on the state of the block address 
    if instruction == 'Invalidate':
      invalidate_cache_copy(block_addr, p)
    elif instruction == 'load':
      load_block_copy(block_addr, p)
    elif instruction == 'store':
      store_block_copy(block_addr, p, data)
    elif instruction == 'Fwd_GetS':
      forward_getS_request(block_addr, p)
    elif instruction == 'Fwd_GetM':
      forward_getM_request(block_addr, p, action[3])
    elif instruction == 'REPLACEMENT':
      replace_block_copy(block_addr)


  def invalidate_cache_copy(addr, p):
    result = [] 
    for x in local_cache:
      if x[0]==addr:
        result=x
        break

    send(('Inv_Ack', addr, p),to=p)

    index = local_cache.index(result)
    tuple = local_cache.pop(index)

    if tuple[1] == 'SHARED':
       local_cache.insert(index,(tuple[0],'INVALID',tuple[2]))
       current_state='INVALID' 
    elif tuple[1] == 'SMAD':
       local_cache.insert(index,(tuple[0],'IMAD',tuple[2], 0))
       current_state='IMAD'
    elif tuple[1] == 'SIA':
       local_cache.insert(index,(tuple[0],'IIA',tuple[2]))
       current_state='IIA'

  def load_block_copy(addr, p):
    result = [] 
    for x in local_cache:
      if x[0]==addr:
        result=x
        break
 
    if len(result)>0:
      state = result[1]
      if state == "INVALID":
        update_cache(result)
        current_state = 'INVALID'
        transition_I_toS(addr)
      elif state in ['SHARED','MODIFIED','OWNED']:
        current_state = 'SHARED'
        update_cache(result)
      else:
        print('LOAD: State not supported!')
    else:
       add_to_cache((addr, 'INVALID', 0))
       current_state = 'INVALID'
       transition_I_toS(addr)

    current_state="READY"
    send('completed', to=p)


  def store_block_copy(addr, p, data):
    result = [] 
    for x in local_cache:
      if x[0]==addr:
        result=x
        break
 
    if len(result): 
      state = result[1]
      if state == "INVALID":
        current_state = "INVALID"
        update_cache(result)
        transition_I_toM(addr, data)
      elif state == 'SHARED':
        current_state = "SHARED"
        update_cache(result)
        transition_S_toM(addr, data)
      elif state == "MODIFIED":
        update_cache(result)
      elif state == "OWNED":
        current_state = "OWNED"
        update_cache(result)
        transition_O_toM(addr, data)
      else:
        print('STORE: State not supported!')
    else:
       current_state = "INVALID"
       add_to_cache((addr, 'INVALID', 0))
       transition_I_toM(addr, data)

    current_state="READY"
    send('completed', to=p)
 
  def replace_block_copy(tuple):
    if tuple[1]=='SHARED':
      send(('PutS',tuple[0]), to=DC)
      current_state='SIA'
      await(current_state=='INVALID')
    elif tuple[1] in ['MODIFIED', 'OWNED']:
      if tuple[1]=='MODIFIED':
        send(('PutM',tuple[0],tuple[2]), to=DC)
        current_state='MIA'
      elif tuple[1]=='OWNED':
        send(('PutE',tuple[0]), to=DC)
        current_state='OIA'
      await(current_state=='INVALID')

      local_cache.remove(tuple)

    current_state = 'READY'

  def forward_getS_request(addr, p):
    result = [] 
    for x in local_cache:
      if x[0]==addr:
        result=x
        break

    index = local_cache.index(result)
    tuple = local_cache.pop(index)

    orig_state = tuple[1]
    state = '' 

    if orig_state in ['MODIFIED']:
      state = 'OWNED'
    elif orig_state in ['MIA']:
      state = 'OIA'
      current_state = state

    if state in ['OWNED', 'OIA']: 
      local_cache.insert(index,(tuple[0], state,tuple[2]))
    else:
      local_cache.insert(index,tuple); 

    if state != '' or orig_state in ['O', 'OMAC', 'OIA', 'OMA']:
      send(('data_from_Owner',result[0],result[2]), to=p)

  def forward_getM_request(addr, p, ack):
    result = [] 
    for x in local_cache:
      if x[0]==addr:
        result=x
        break


    state = ''
    index = local_cache.index(result)
    tuple = local_cache.pop(index)
    orig_state = tuple[1]
    

    if orig_state in ['MODIFIED', 'OWNED']:
      state = 'INVALID'
      current_state = 'INVALID'
    elif orig_state in ['MIA', 'OIA']:
      state = 'IIA'
      current_state='IIA'
    elif orig_state in ['OMAC']:
      state = 'IMAD'
      current_state='IMAD'

    local_cache.insert(index,(tuple[0], state,tuple[2], ack))

    send(('data_from_Owner',result[0],result[2]),to=p)

  def transition_I_toS(addr):
    current_state='ISD'
    tuple = local_cache.pop(0)
    local_cache.insert(0,(tuple[0],current_state,tuple[2]))
    send(('GetS',addr),to=DC)

    await(current_state=='SHARED')
    
  def transition_I_toM(addr, data):
    current_state='IMAD'
    tuple = local_cache.pop(0)
    local_cache.insert(0,(tuple[0],current_state,tuple[2], 0)) 
    send(('GetM',addr),to=DC)

    transition_IMAD_toM(addr, data)
    t=local_cache.pop(0)
    local_cache.insert(0,(tuple[0],current_state,data))
    

  def transition_IMAD_toM(addr, data):
    await(current_state=='IMA' or current_state=='MODIFIED')
    if current_state=='MODIFIED':
      pass
    else:
      await(current_state == 'MODIFIED')

  def transition_S_toM(addr, data):
    current_state='SMAD'
    tuple = local_cache.pop(0)
    local_cache.insert(0,(tuple[0],current_state,tuple[2])) 
    send(('GetM',addr),to=DC)

    await(current_state=='SMA' or current_state=='MODIFIED' or current_state=='IMAD')
    if current_state == 'MODIFIED':
      pass
    elif current_state=='SMA':
      await(current_state=='MODIFIED')
    elif current_state=='IMAD':
      transition_IMAD_toM(addr, data)
    else:
      print('IMAD_to_M: Invalid State!')

    tuple=local_cache.pop(0)
    local_cache.insert(0,(tuple[0],current_state,data))

    current_state = 'READY'

  def transition_O_toM(addr, data):
    current_state='OMAC'
    tuple = local_cache.pop(0)
    local_cache.insert(0,(tuple[0],current_state,tuple[2])) 
    send(('GetM',addr),to=DC)

    await(current_state=='OMA' or current_state=='MODIFIED')
    if current_state == 'MODIFIED':
      pass
    elif current_state == 'OMA':
      await(current_state == 'MODIFIED')
      transition_IMAD_toM(addr, data)
    else:
      print('O_to_M: Invalid State!')

    tuple=local_cache.pop(0)
    local_cache.insert(0,(tuple[0],current_state,data,))
    current_state = 'READY' 
 
  def transition_M_toO():
    pass

  def receive(msg=('data_from_DC', ack_cnt, addr, data), from_=s):
    if current_state=='ISD' and addr==local_cache[0][0] and ack_cnt==0:
      current_state = "SHARED"
      tuple = local_cache.pop(0)
      local_cache.insert(0, (tuple[0], current_state, data, ack_cnt))
    elif ((current_state=='IMAD' or current_state=='SMAD') and addr==local_cache[0][0] and ack_cnt==0):
      current_state = "MODIFIED"
      tuple = local_cache.pop(0)
      local_cache.insert(0, (tuple[0], current_state, data, ack_cnt))
    elif current_state=='IMAD' and addr==local_cache[0][0] and ack_cnt>0:
      current_state = "IMA"
      tuple = local_cache.pop(0)
      local_cache.insert(0, (tuple[0], current_state, data, ack_cnt))
    elif current_state=='SMAD' and addr==local_cache[0][0] and ack_cnt>0:
      current_state = "SMA"
      tuple = local_cache.pop(0)
      local_cache.insert(0, (tuple[0], current_state, data, ack_cnt))

    else:
      print('Data from DC: State not Supported!')

  def receive(msg=('data_from_Owner', addr, data), from_=s):
    if current_state=='ISD' and addr==local_cache[0][0]:
      current_state = "SHARED"
      tuple = local_cache.pop(0)
      local_cache.insert(0, (tuple[0], current_state, data, 0))
    elif ((current_state=='IMAD' or current_state=='SMAD') and addr==local_cache[0][0]):
      current_state = "MODIFIED"
      tuple = local_cache.pop(0)
      local_cache.insert(0, (tuple[0], current_state, data, 0))
    else:
      print('Data from Owner: State not Supported!')


  def receive(msg=('Inv_Ack',addr,p), from_=s):
    states = ['IMA', 'IMAD', 'OMA', 'OMAC', 'SMAD', 'SMA']
    if (current_state in states) and addr==local_cache[0][0]:
      tuple = local_cache.pop(0)
      ack_cnt = tuple[3]
      ack_cnt -= 1
      if ack_cnt==0:
        current_state = "MODIFIED"

      local_cache.insert(0, (tuple[0], current_state, tuple[1], ack_cnt))
    else:
      print('State not Supported!')
  

  def receive(msg=('Invalidate', p, addr), from_=s):
    result=[] 
    for x in local_cache:
      if x[0] == addr:
        result = x[1]
        break 
	 
    if (result == "SHARED" or result == "SMAD" or result == "SIA"):
      invalidate_cache_copy(addr, p)
    else:
      pending_actions.append(('Invalidate', addr, p))
 
  def add_to_cache(tuple):
    if len(local_cache) >= CACHE_SIZE:
      value=local_cache[len(local_cache)-1]
      if value[1] in ['SHARED', 'MODIFIED', 'OWNED']:
        pending_actions.insert(0,('REPLACEMENT',value,None))
    else:   
      local_cache.insert(0, tuple)
  
  def update_cache(tuple):
    local_cache.remove(tuple)
    local_cache.insert(0, tuple)
      
  def receive(msg=('Fwd_GetS', p, addr), from_=s):
    res=[x for x in local_cache if x[0]==addr]
    if res[0][1] in ['MODIFIED', 'OWNED', 'MIA', 'OMA', 'OMAC', 'OIA']:
      forward_getS_request(addr,p)
    else:
      pending_actions.append(('Fwd_GetS', addr, p))

  def receive(msg=('Fwd_GetM', p, addr, ack), from_=s):
    res=[x for x in local_cache if x[0]==addr]
    if res[0][1] in ['MODIFIED', 'OWNED', 'MIA', 'OMAC', 'OIA']:
      forward_getM_request(addr,p,ack)
    else:
      pending_actions.append(('Fwd_GetM', addr, p, ack))

  def receive(msg=('load',addr, p), from_=s):
    self.pending_actions.append(('load',addr, s))
    print('received Load request for block : ', addr, " ", s)

  def receive(msg=('store',addr, p, data), from_=s):
    self.pending_actions.append(('store',addr, s))
    print('received Store request for block : ', addr, " ", s)

  def receive(msg=('Put_Ack',addr,p), from_=s):
    res = [ x for x in local_cache if x==addr]
    if current_state in ['SIA','IIA','MIA','OIA']:
      index=local_cache.index(res[0])
      t=local_cache.pop(index)
      local_cache.insert(index,(t[0],'INVALID',t[2]))
      current_state='INVALID'
    else:
      print('Invalid state!')

  def receive(msg=('Ack_cnt',ack,addr), from_=s):
    res = [ x for x in local_cache if x==addr]
    if current_state == 'OMAC':
      current_state='OMA'
      t=local_cache.pop(0)
      local_cache.insert(0,(t[0],current_state,t[2], ack))

  def receive(msg= ('done',)):
    print("Cache Exiting\n")
    exit() 


# Processor 
class Processor(process):
    def setup(trace, protocol):
      self.keep_waiting = False
      ## self.cache = Cache(protocol, CACHE_SIZE)

    def execute(inst):
      if inst[0] == "r":
        send(('load',inst[1] , self.id), to=protocol)

      elif inst[0] == "w":
        send(('store', inst[1], self.id, inst[2]), to=protocol)

      else:
        print("Unexpected instruction:", inst);

    def run():
      for inst in trace:
        keep_waiting = False
        execute(inst)
        await(keep_waiting)

      print("Processor Exits", self.id)

    def receive(msg= ('completed')):
      print("ACKed\n")
      keep_waiting = True

def get_traces(trace_dir,nprocs):
  trace=[]
  for i in range(nprocs):
    trace_filename='p'+str(i)+'.trace'
    f=open(os.path.join(trace_dir,trace_filename))
    insts=[]
    for line in f:      
      insts.append(line.split())
    trace.append(insts)
  return trace

class Monitor(process):
  def setup():
    self.instructions = []
    self.total_msgs = 0
    self.cpu_time = 0
    self.elapsed_time = 0
   
  def receive(msg= ('ins', type, addr, value, cache_id,lc)):
    instructions.append((type, addr, value, cache_id,lc))

  def receive(msg= ('inc_msg_cnt', value)):
    total_msgs = total_msgs + value

  def receive(msg= ('time_taken', cpu, elapsed)):
    cpu_time = cpu
    elapsed_time = elapsed 

  def run():
    await(False)
    
  def receive(msg= ('done',)):
    print("===Load/Store global order===")
    for ins in instructions:
      print(ins[3], " : ", ins[0], ins[1], ins[2])
    print()
    print("===Benchmarks===")
    print("Total msg count:", total_msgs)
    print("Elapsed time:", elapsed_time)
    print("CPU time:", cpu_time)
    exit()


def main():
    nprocessors = int(sys.argv[1]) if len(sys.argv) > 1 else 2
    proto_name = sys.argv[2] if len(sys.argv) > 2 else 'MI'
    trace_dir = sys.argv[3] if len(sys.argv) > 3 else './traces'

    config(channel= 'fifo', clock= 'Lamport')
    
    start_cpu_time = time.process_time()
    start_elapsed_time = time.perf_counter()    
    
    trace = get_traces(trace_dir,nprocessors)
    #print(trace)
    Proto_cache, Proto_ctrl = get_proto_class(proto_name)
    
    print('-----START-----')
    ## Start monitor process
    monitor_obj = new(Monitor, num=1)
    setup(monitor_obj, ())
    start(monitor_obj)

    
    ## Initialize protocol objs for caches and controller
    mem_ctrl_protocol_obj = new(Proto_ctrl, num=1)
    protocol_objs = new(Proto_cache, num=nprocessors)
    
    ## Setup Protocol for ctrller
    setup(mem_ctrl_protocol_obj, (protocol_objs,monitor_obj))
    start(mem_ctrl_protocol_obj)

    ## Setup Protocols for caches
    for proto_obj in protocol_objs:
      setup(proto_obj, (mem_ctrl_protocol_obj, protocol_objs - {proto_obj}, CACHE_SIZE,monitor_obj))
      start(proto_obj)

    ## Setup Processors
    processors = new(Processor, num= nprocessors)
    
    ## temp lists for iterating
    processors_list = list(processors)
    protocol_objs_list = list(protocol_objs)
    for i in range(nprocessors): 
      setup(processors_list[i], (trace[i], protocol_objs_list[i],monitor_obj))
    
    start(processors)
    
    ## Exiting logic  
    for p in processors: 
      p.join()

    da.send(('done',), to= protocol_objs)
    for m in protocol_objs:
      m.join()

    da.send(('done',), to= mem_ctrl_protocol_obj)
    for m in mem_ctrl_protocol_obj:
      m.join()

    end_cpu_time = time.process_time()
    end_elapsed_time = time.perf_counter()

    da.send(('time_taken', end_cpu_time-start_cpu_time, end_elapsed_time-start_elapsed_time), to= monitor_obj)
    
    da.send(('done',), to= monitor_obj)
    for monitor in monitor_obj:
      monitor.join()
    print('-----END-----')
