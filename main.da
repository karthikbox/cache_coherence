import sys

ENOTSUPP = 2
CACHE_SIZE = 512

def get_proto_class(name):
  if name == "MI":
    return (eval("MI_PROTO_CACHE"), eval("MI_PROTO_CTRL"))
  else:
    exit(-ENOTSUPP)

## Exemplary implementation of PROTOCOL Classes
class MI_PROTO_CACHE(process):
  def setup(cache_protocol_obj, other_protocol_obj):
    pass
  
  def run():
    pass
  
  def get_header():
    return (0, 0)

  ## def load(addr, ctx):
  ##   send('msg', to=memory_ctrl)

class MI_PROTO_CTRL(process):
  def setup(cache_protocol_objs):
    pass
  
  def run():
    pass
  
  def get_header():
    return (0, 0)

  ## def load(addr, ctx):
  ##   send('msg', to=memory_ctrl)


class Cache():
  """LRU cache instantiate with a particular protocol"""
  def __init__(self, protocol, size):
    self.memory = [(protocol.get_header(), "0x00000000") for i in range(size)]
  
  def __reorder(self, addr):
    """Maintain LRU order after access to addr"""

    if addr in self.memory: 
      self.memory.remove(addr)
    else:
      self.memory.pop()
    
    self.memory.insert(0,addr)

  def load(self, addr):
    """Called by processor"""
    self.protocol.load(addr)
    self.__reorder(addr)

  def store(self, addr):
    """Called by processor"""
    self.protocol.store(addr)
    self.__reorder(addr)

class Processor(process):
    def setup(trace, protocol):
      self.cache = Cache(protocol, CACHE_SIZE)
    
    def execute(inst):
      type, addr = inst
      if type == "r":
        cache.load(addr, self)
      
      elif type == "w":
        cache.store(addr, self)
      
      else:
        print("Unexpected instruction:", inst);
    
    def run():
      for inst in trace:
        execute(inst)
      protocol.join()

class Memory_Controller():
    def __init__(self, protocol):
      start(protocol)
      self.protocol = protocol
      print("Initialized memory controller");

    def register_caches(self, protocol_objs):
      self.caches = protocol_objs

    def run(self):
      self.protocol.join()

def get_traces(trace_file):
  return [
          [('r', '0x11111111'),
          ('r', '0x11111111'),
          ('r', '0x11111111')],

          [('r', '0x11111111'),
          ('r', '0x11111111'),
          ('r', '0x11111111')]
         ]

def main():
    nprocessors = int(sys.argv[1]) if len(sys.argv) > 1 else 2
    proto_name = sys.argv[2] if len(sys.argv) > 2 else 'MI'
    trace_file = sys.argv[3] if len(sys.argv) > 3 else exit(-1)
    
    trace = get_traces(trace_file)
    Proto_cache, Proto_ctrl = get_proto_class(proto_name)
    
    ## Initialize protocol objs for caches and ctrller
    mem_ctrl_protocol_obj = new(Proto_ctrl, num=1)
    protocol_objs = new(Proto_cache, num=nprocessors)
    
    ## Setup Protocol for ctrller
    setup(mem_ctrl_protocol_obj, (protocol_objs))
    start(mem_ctrl_protocol_obj)

    ## Setup Protocols for caches
    for proto_obj in protocol_objs:
      setup(proto_obj, (mem_ctrl_protocol_obj, (protocol_objs - {proto_obj})))
      start(proto_obj)

    ## Setup Memory Controller
    memory_ctrl = Memory_Controller(mem_ctrl_protocol_obj)
    
    ## Setup Processors
    processors = new(Processor, num= nprocessors)
    
    ## temp lists for iterating
    processors_list = list(processors)
    protocol_objs_list = list(protocol_objs)
    for i in range(nprocessors): 
      setup(processors_list[i], (trace[i], protocol_objs_list[i]))
    
    start(processors)

    for p in processors: 
      p.join()
    
    da.send(('done',), to= mem_ctrl_protocol_obj)
    print('-----END-----')         

