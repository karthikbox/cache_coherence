import sys
import time

ENOTSUPP = 2
CACHE_SIZE = 512

def get_proto_class(name):
  if name == "MI":
    return (eval("MI_PROTO_CACHE"), eval("MI_PROTO_CTRL"))
  else:
    exit(-ENOTSUPP)

## Exemplary implementation of PROTOCOL Classes
"""
  MI Protocol class:
"""
class MI_PROTO_CACHE(process):
  def setup(dir_ctrlr, other_caches, size):
    self.memory = []
    
    self.pending_actions=[]
    self.current_state="READY"
    
    
  def run():
    while(1):
      await(len(self.pending_actions)>0 and current_state=="READY")
      #queue has some pending request and  state is READY
      #process request
      processRequest()

  def processRequest():
    #deque request
    (inst,addr,to_process)=pending_actions.pop()
    #possible instructions are : loads,stores, invlalidate
    if(inst=='invalidate'):
      perform_invalidation(addr,to_process)
    elif inst=='load':
      perform_load(addr,to_process)
    elif inst=='store':
      perform_store(addr,to_process)

  def perform_invalidation(addr,to_process):
    assert current_state=='READY', "state is not in READY state but in %r" % current_state
    pass

  def perform_load(addr,to_process):
    """ load the value of a particular address in the cache. """
    assert current_state=='READY', "state is not in READY state but in %r" % current_state
    # check state of addr in mem
    # tuple in memory is of the form (addr,status,value)
    res=[x  for x in memory if x[0]==addr ]
    if len(res)>0:
      # if addr was present in memory
      assert res[0][0]==addr,"memory should have 'addr' but has %r" % res[0][0]
      if res[0][1]=='INVALID':
        # move this addr to the head of the memory list, update LRU
        update_lru_position_of(res[0])
        # make transition from I to S/E
        current_state='INVALID'
        move_I_to_SorE(addr)
      elif res[0][1] in ['SHARED','MODIFIED','EXCLUSIVE']:
        # since state is ANY OF THE ABOVE, update lru and return the value
        update_lru_position_of(res[0])
      else:
        assert False, "invalid state %r" % res[0][2]
    else:
      # addr iis not present in memory
      # add addr to memory.
      # add_to_memory, adds new item to the HEAD of memory list with an INVALID state
      add_to_memory((addr,'INVALID',0))
      current_state='INVALID'
      move_I_to_SorE(addr)
    # requested addr should be at the head of the memory
    assert memory[0][0]==addr, "newly loaded memory invariant failed for addr,state= %r, %r" % (memory[0][0],memory[0][1])
    assert memory[0][1]!='INVALID', "newly loaded memory invariant failed for addr,state= %r, %r" % (memory[0][0],memory[0][1])    
    current_state='READY'
    print("Sending Ack")
    send('completed', to=to_process)
    print("value returned to processor =%r" % memory[0][2])

  def perform_store(addr,to_process):
    """ store the value of a particular address in the cache. """
    assert current_state=='READY', "state is not in READY state but in %r" % current_state
    pass

  
  def move_I_to_SorE(addr):
    res=[x for x in memory if x[0]==addr]
    assert len(res)>0,"couldnt find addr in memory"
    assert memory[0][0]==addr,"current addr request should be at he head of memory LRU, but it isn not"
    assert memory[0][1]==current_state,'memory state corrupted'
    # addr_t,state_t,val_t=memory.pop()
    # memory.insert(0,(addr_t,'SHARED',val_t))
    # when in INVALID, on load, send getS to DC and goto ISD
    # possible msgs to be recevied: ('exclusive_data_from_dir'),('data_from_dir',ack=0),('data_from_owner')
    current_state='INVALID_SHARED_DATA'
    addr_t,state_t,val_t=memory.pop()
    memory.insert(0,(addr_t,current_state,val_t))
    # inform DC
    send(('GetS',addr),to=dir_ctrlr)
    # await till state changes
    await(current_state=='SHARED' or current_state=='EXCLUSIVE')
    assert memory[0][1]!='INVALID_SHARED_DATA','memory state corrupted'
    return
  
  def add_to_memory(t):
    """ add tuple t to the head of memory list. format of tuple t = (address,state,value) """
    # check size of memory, if >= CACHE_SIZE, pop the last element and add the new tuple at the head
    # otherwise, insert at head directly
    if len(memory) >= CACHE_SIZE:
      popped=memory.pop()
      # if state of popped is SHARED, MODIFIED, EXCLUSIVE
      if popped[1] in ['SHARED', 'MODIFIED', 'EXCLUSIVE']:
        # queue it at the head of pending request so that it will be the next instruction to be executed
        # any message requesting action on the evicted addr will be added to the end of the pending_actions queue,
        # so write back/replacement will happen before the we get to that previously mentioned message on that addr.
        pending_actions.insert(0,('REPLACEMENT',popped[1],None))
      else:
        # if state is INVALID, just remove the item from the memory(already done with pop), no action needed
        assert popped[1]=='INVLAID', "state corrupted for memory item  %r" % popped
    # add tuple t to the head of og the memory list
    memory.insert(0,t)
    

  def update_lru_position_of(t):
    """ move tuple t to the head of the memory list. t=(address,state,value) """
    # t should be present int the memory list
    assert t in memory, "tuple %r should exist in memory"
    memory.remove(t)
    memory.insert(0,t)

# STATES : message handlers written
# INVALID_SHARED_DATA : 
# to_handle(exclusive_data_from_dir, data_from_dir, data_from_owner)
# stall(invalidate,replacement)
  
  def receive(msg=('exclusive_data_from_dir',addr,val_rvd), from_=s):
#     print ("addr rcvd=%r   addr required=%r" %(addr,memory[0][0]))
#     print("state=%r  mem state=%r" %(current_state,memory[0][1]))
    if current_state=='INVALID_SHARED_DATA' and addr==memory[0][0]:
      # move to EXCLUSIVE state, update the state in memory for the address
      current_state='EXCLUSIVE'
      addr_t,state_t,val_t=memory.pop()
      memory.insert(0,(addr_t,current_state,val_rvd))
      assert state_t=='INVALID_SHARED_DATA','memory state corrupted'
    else:
      assert False, "received out-of-state message. Should not happen. exclusive_data_from_dir"

  def receive(msg=('data_from_dir',ack,addr,val_rvd), from_=s):
    if current_state=='INVALID_SHARED_DATA' and addr==memory[0][0] and ack==0:
      # move to SHARED state
      current_state='SHARED'
      addr_t,state_t,val_t=memory.pop()
      memory.insert(0,(addr_t,current_state,val_rvd))
      assert state_t=='INVALID_SHARED_DATA','memory state corrupted'
    else:
      assert False, "received out-of-state message. Should not happen. data_from_dir"

  def receive(msg=('data_from_owner',addr,val_rvd), from_=s):
    if current_state=='INVALID_SHARED_DATA' and addr==memory[0][0]:
      # move to SHARED state
      current_state='SHARED'
      addr_t,state_t,val_t=memory.pop()
      memory.insert(0,(addr_t,current_state,val_rvd))
      assert state_t=='INVALID_SHARED_DATA','memory state corrupted'
    else:
      assert False, "received out-of-state message. Should not happen. data_from_owner"
  

  def receive(msg=('invalidate',addr,p), from_=s):
    # state is INVALID_SHARED_DATA, then stall it, p is original cache id
    pending_actions.append('invalidate',addr,p)

  def receive(msg=('Fwd_GetS',addr,p), from_=s):
    # state is INVALID_SHARED_DATA, then stall it, p is original cache id
    pending_actions.append('fwd_gets',addr,p)

  def receive(msg=('Fwd_GetM',addr,p), from_=s):
    # state is INVALID_SHARED_DATA, then stall it, p is original cache id
    pending_actions.append('fwd_getm',addr,p)


  def receive(msg=('load',addr, p), from_=s):
    self.pending_actions.append(('load',addr, s))
    print("Received LOAD request for addr %s" % addr)
    # if (1,addr) not in self.memory:
    #   """ Cache miss logic """
    #   get_addr(addr)
    # self.reorder(addr)
    # print("Sending Ack")
    # send('completed', to=s)
  
  def receive(msg=('store',addr, p), from_=s):
    self.pending_actions.append(('load',addr, s))
    print("Received STORE request for addr %s" % addr);
#    if (1,addr) not in self.memory:
#      """ Cache miss logic """
#      get_addr(addr)
#    self.reorder(addr)
#    print("Sending Ack")
#    send('completed', to=s)
  
  def receive(msg= ('done',)):
    print("Cache Exiting\n")
    exit()

class MI_PROTO_CTRL(process):
  def setup(cache_protocol_objs):
    self.pending_actions=[]
    self.memory = dict()

  def run():
    while(1):
      await(len(self.pending_actions)>0)
      #queue has some pending request and  state is READY
      #process request
      processRequest()

  
  def processRequest():
    # deque request
    t=pending_actions.pop()
    #possible instructions are : loads,stores, invlalidate
    # pending_actions tuple format : (inst,addr,to_process,data)
    # check if addr is in memory, else add it to memory with INVALID state
    if(t[1] not in memory):
      memory[t[1]]=['INVALID',self.id,[],555]

    if(t[0]=='GetS'):
      perform_getS(t[1],t[2])
#     elif(t[0]=='GetM'):
#       perform_getM(t[1],t[2])
#     elif(t[0]=='PutS'):
#       perform_putS(t[1],t[2])
#     elif(t[0]=='PutM'):
#       perform_putM(t[1],t[2],t[3])
#     elif(t[0]=='PutE'):
#       perform_putE(t[1],t[2])
    else:
      assert False,'invalid request in pending actions queue'


  def perform_getS(addr,to_process):
    # key -value : memory_addr, [state,owner,[sharers],value]
    assert addr in memory, "address %r not in memory" % addr
    if memory[addr][0]=='INVALID':
      # send exclusive data to req, set owner to req, set state to exclusive
      send(('exclusive_data_from_dir',addr,memory[addr][3]),to=to_process)
      memory[addr][1]=to_process
      memory[addr][0]="EXCLUSIVE"
    elif memory[addr][0]=='SHARED':
      # send data to req with ack=0, add req to sharers list, no change to state
      memory[addr][2].append(to_process)
      send(('data_from_dir',0,addr,memory[addr][3]),to=to_process)
    elif memory[addr][0]=='EXCLUSIVE':
      # forward GetS to owner, make owner as sharer, clear owner
      # add req to sharers, make state as SHARED_DATA
      send(('Fwd_GetS',addr,to_process),to=memory[addr][1])
      memory[addr][2].append(memory[addr][1])
      memory[addr][2].append(to_process)
      memory[addr][1]=None
      memory[addr][0]='SHARED_DATA'
      # await for data from the exclusive owner ???
    elif memory[addr][0]=='MODIFIED':
      # forward getS to owner, maker onwer sharer, clear owner
      # add req to shareers, make state as SHARED_DATA
      send(('Fwd_GetS',addr,to_process),to=memory[addr][1])
      memory[addr][2].append(memory[addr][1])
      memory[addr][2].append(to_process)
      memory[addr][1]=None
      memory[addr][0]='SHARED_DATA'
      # await for data from the MODIFIED owner 
      await(memory[addr][0]=='SHARED')
    else:
      assert False, 'invalid memory state'

  def receive(msg=('GetS',addr), from_=p):
    """ Put it in pending queue"""
    pending_actions.append(('GetS',addr,p))

  def receive(msg= ('GetM',addr), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('GetM',addr,p))

  def receive(msg= ('PutS',addr), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('PutS',addr,p))

  def receive(msg= ('PutM',addr,data), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('PutM',addr,p,data))

  def receive(msg= ('PutE',addr), from_= p):
    """ Put it in pending queue"""
    pending_actions.append(('PutE',addr,p))

  def receive(msg= ('data',addr,data), from_= p):
    """ Do not queue"""
    # receiveing data, that means, addr should be in memory
    assert addr in memory, "addr=%r not present in DC memory" % addr
    assert current_state=='SHARED_DATA','invalid data received'
    # key -value : memory_addr, [state,owner,[sharers],value]
    assert memory[addr][0]=='SHARED_DATA','invalid memory state'
    # update value, update state to 'SHARED'
    memory[addr][3]=data
    memory[addr][0]='SHARED'


  def receive(msg= ('done',)):
    print("CTRL Exiting\n")
    exit()

class Processor(process):
    def setup(trace, protocol):
      self.keep_waiting = False
      ## self.cache = Cache(protocol, CACHE_SIZE)
    
    def execute(inst):
      type, addr = inst
      if type == "r":
        send(('load', addr, self.id), to=protocol)
     
      elif type == "w":
        send(('store', addr, self.id), to=protocol)
      
      else:
        print("Unexpected instruction:", inst);
    
    def run():
      for inst in trace:
        keep_waiting = False
        execute(inst)
        await(keep_waiting)

      print("Processor Exits")

    def receive(msg= ('completed')):
      print("ACKed\n")
      keep_waiting = True

def get_traces(trace_file):
  return [
          [
           ('r', '0x11111111'),
           ('r', '0x11111112'),
           ('w', '0x11111113')
          ],

          [
           ('r', '0x11111111'),
           ('w', '0x11111115'),
           ('r', '0x11111112')
          ]
         ]

def main():
    nprocessors = int(sys.argv[1]) if len(sys.argv) > 1 else 2
    proto_name = sys.argv[2] if len(sys.argv) > 2 else 'MI'
    #trace_file = sys.argv[3] if len(sys.argv) > 3 else exit(-1)
    trace_file = sys.argv[3] if len(sys.argv) > 3 else 'none'
    
    trace = get_traces(trace_file)
    Proto_cache, Proto_ctrl = get_proto_class(proto_name)
    
    ## Initialize protocol objs for caches and controller
    mem_ctrl_protocol_obj = new(Proto_ctrl, num=1)
    protocol_objs = new(Proto_cache, num=nprocessors)
    
    ## Setup Protocol for ctrller
    setup(mem_ctrl_protocol_obj, (protocol_objs,))
    start(mem_ctrl_protocol_obj)

    ## Setup Protocols for caches
    for proto_obj in protocol_objs:
      setup(proto_obj, (mem_ctrl_protocol_obj, protocol_objs - {proto_obj}, CACHE_SIZE))
      start(proto_obj)

    ## Setup Processors
    processors = new(Processor, num= nprocessors)
    
    ## temp lists for iterating
    processors_list = list(processors)
    protocol_objs_list = list(protocol_objs)
    for i in range(nprocessors): 
      setup(processors_list[i], (trace[i], protocol_objs_list[i]))
    
    start(processors)
    
    ## Exiting logic  
    for p in processors: 
      p.join()

    da.send(('done',), to= protocol_objs)
    for m in protocol_objs:
      m.join()

    da.send(('done',), to= mem_ctrl_protocol_obj)
    for m in mem_ctrl_protocol_obj:
      m.join()
    print('-----END-----')

