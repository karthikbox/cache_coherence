import sys
import time

ENOTSUPP = 2
CACHE_SIZE = 512

M = 2
S = 1
I = 0

def get_proto_class(name):
  if name == "MSI":
    return (eval("MSI_PROTO_CACHE"), eval("MSI_PROTO_CTRL"))
  else:
    exit(-ENOTSUPP)

"""
  MSI Protocol class:
"""
class MSI_PROTO_CACHE(process):
  def setup(mem_ctrl_protocol_obj, other_protocol_obj, size, monitor_obj):
    self.memory = []
    self.get_from_caches = False
    self.wait_for_caches = False
    self.wait_for_memory = False
    self.get_from_memory = False
    self.wait_for_eviction = False
    self.not_found_q = []
    self.pending_actions = []
    
  def run():
    await(False)

  def reorder(state, address, value):
    """ Check if the address is present in the list """
    found = False
    for (s, addr, val) in self.memory:
      if addr == address:
        found = True

        if s != I and value == "":
          value = val
        
        self.memory.remove((s, address, val))
        break
    
    if not found:
      """ Check if the cache is full """
      if len(self.memory) == size:
        print("Cache is full")
        (s, last_addr, val) = self.memory.pop()
        if s == M:
          send(('flush', last_addr, value), to=mem_ctrl_protocol_obj)
          send(('inc_msg_cnt', 1), to=monitor_obj)

    self.memory.insert(0, (state, address, value))
    return value
 
  def receive(msg=('load', address), from_=p):
    print("Received LOAD request for addr %s" % address);
    found = False
    value = ""
    state = I
    
    for (s, addr, val) in self.memory:
      if s != I and address == addr:
        found = True
        state = s 
        break
      
    if not found:
      wait_for_caches = False;
      send(('loadF', address), to=other_protocol_obj)
      send(('inc_msg_cnt', len(other_protocol_obj)), to=monitor_obj)
      await(wait_for_caches)
      if not get_from_caches:
        wait_for_memory = False
        send(('get', address), to=mem_ctrl_protocol_obj)
        send(('inc_msg_cnt', 1), to=monitor_obj)
        await(wait_for_memory)
      else:
        get_from_caches = False
      state = S

    value = self.reorder(state, address, '')
    self.not_found_q.clear()
    print("Sending Ack")
    send(('completed_load', value), to=p)
    send(('inc_msg_cnt', 1), to=monitor_obj)
  
  def receive(msg=('store', address, value), from_=p):
    print("Received STORE request for addr %s" % address);
    found_state = ""  

    for (s, addr, val) in self.memory:
      if address == addr:
        found_state = s 
        break
    
    if found_state == S:
      send(('invalidate', addr), to=other_protocol_obj)
      send(('inc_msg_cnt', len(other_protocol_obj)), to=monitor_obj)
      """ Do we need wait here ? """
      wait_for_eviction = False

    elif found_state == I or found_state == "":
      wait_for_caches = False
      send(('storeF', addr), to=other_protocol_obj)
      send(('inc_msg_cnt', len(other_protocol_obj)), to=monitor_obj)
      await(wait_for_caches)
      
      if not get_from_caches:
        wait_for_memory = False
        send(('get', addr), to=mem_ctrl_protocol_obj)
        send(('inc_msg_cnt', 1), to=monitor_obj)
        await(wait_for_memory)
      else:
        get_from_caches = False
    
    state = M

    self.reorder(state, address, value)
    self.not_found_q.clear()
    print("Sending Ack")
    send(('completed_store', value), to=p)
    send(('inc_msg_cnt', 1), to=monitor_obj)
    print('reaching here store')
  
  def receive(msg= ('done',)):
    print("Cache Exiting\n")
    exit()
  
  def receive(msg= ('loadF',address), from_= p):
    """ Add time delay here to mimic cache-to-cache latency """
    time.sleep(1)
    print("Cache request for address: %s", address)
    print(self.memory)
    
    found_state = ""
    found_value = ""
    
    for (s, addr, val) in self.memory:
      if addr == address: 
        found_state = s
        found_value = val
        break 

    if found_state == M:
      i = self.memory.index((found_state, address, found_value))
      self.memory[i] = (S, self.memory[i][1], self.memory[i][2]) 
      send(('flush', address, found_value), to=mem_ctrl_protocol_obj)
      send(('inc_msg_cnt', 1), to=monitor_obj)
      send(('found_in_cache', address, found_value), to=p)
      send(('inc_msg_cnt', 1), to=monitor_obj)

    elif found_state == S:
      send(('found_in_cache', address, found_value), to=p)
      send(('inc_msg_cnt', 1), to=monitor_obj)
    
    else:
      send(('not_found_in_cache', address), to=p)
      send(('inc_msg_cnt', 1), to=monitor_obj)

  def receive(msg= ('storeF',address), from_= p):
    """ Add time delay here to mimic cache-to-cache latency """
    time.sleep(1)
    print("Cache request for address: ", address)
    print(self.memory)
    
    found_state = ""
    found_value = ""
    
    for (s, addr, val) in self.memory:
      if addr == address: 
        found_state = s
        found_value = val
        break 

    if found_state == M:
      i = self.memory.index((found_state, address, found_value))
      self.memory[i] = (I, self.memory[i][1], self.memory[i][2]) 
      send(('flush', address, found_value), to=mem_ctrl_protocol_obj)
      send(('inc_msg_cnt', 1), to=monitor_obj)
      send(('found_in_cache', address, found_value), to=p)
      send(('inc_msg_cnt', 1), to=monitor_obj)

    elif found_state == S:
      i = self.memory.index((found_state, address, found_value))
      self.memory[i] = (I, self.memory[i][1], self.memory[i][2]) 
      send(('found_in_cache', address, found_value), to=p)
    
    else:
      send(('not_found_in_cache', address), to=p)

  def receive(msg=('invalidate', address), from_= p):
    for i, (s, addr, val) in enumerate(self.memory):
      if addr == address:
        self.memory[i] = (I, addr, val)
        break
  
  def receive(msg=('found_in_cache', address, value)):
    print("Addr:", address, "received from another cache with value:", value)
    for i in range(len(self.memory)):
      if self.memory[i][1] == address:
        self.memory[i] = (self.memory[i][0], address, value)
        break
    get_from_caches = True
    wait_for_caches = True

  def receive(msg=('not_found_in_cache', address)):
    self.not_found_q.append("recvd_not_found")
    if len(self.not_found_q) == len(other_protocol_obj):
      print("Addr", address, "not found in the other caches")
      get_from_caches = False
      wait_for_caches = True 

  def receive(msg=('found_in_memory', address, value)):
    print("Addr:", address, "received from Memory with value:", value)
    for i in range(len(self.memory)):
      if self.memory[i][1] == address:
        self.memory[i] = (self.memory[i][0], address, value)
        break
    get_from_memory = True
    wait_for_memory = True

  def receive(msg=('not_found_in_memory')):
    print("Addr not found in memory")
    wait_for_memory = True

class MSI_PROTO_CTRL(process):
  def setup(cache_protocol_objs, monitor_obj):
    self.memory = dict()
  
  def run():
    await(False)
  
  def receive(msg=('msg')):
    print("recevied msg\n")

  def receive(msg= ('get',addr), from_= p):
    """ Add time delay here to mimic cache-to-memory latency """
    if addr not in self.memory:
        self.memory[addr] = 0
        
    time.sleep(0.1)
    send(('found_in_memory', addr, self.memory[addr]), to=p)
    send(('inc_msg_cnt', 1), to=monitor_obj)

  def receive(msg= ('flush', addr, value)):
    time.sleep(0.1)
    self.memory[addr] = value

  def receive(msg= ('done',)):
    print("CTRL Exiting\n")
    exit()

class Processor(process):
    def setup(trace, protocol, monitor_obj):
      self.keep_waiting = False
      ## self.cache = Cache(protocol, CACHE_SIZE)
    
    def execute(inst):
      type, addr, value = inst
      if type == "r":
        send(('load', addr), to=protocol)
        send(('inc_msg_cnt', 1), to=monitor_obj)
     
      elif type == "w":
        send(('store', addr, value), to=protocol)
        send(('inc_msg_cnt', 1), to=monitor_obj)
      
      else:
        print("Unexpected instruction:", inst);
    
    def run():
      for inst in trace:
        keep_waiting = False
        execute(inst)
        await(keep_waiting)

      print("Processor Exits")

    def receive(msg= ('completed_load', value)):
      print("ACKed load\n", value)
      keep_waiting = True

    def receive(msg= ('completed_store', value)):
      print("ACKed store\n", value)
      keep_waiting = True

def get_traces(trace_file):
  return [
          [
           ('r', '0x11111111', 0),
           ('w', '0x11111111', 3),
           ('w', '0x11111113', 10)
          ],

          [
           ('r', '0x11111114', 0),
           ('r', '0x11111117', 0),
           ('r', '0x11111111', 0)
          ],
          
          [
           ('r', '0x11111117', 0),
           ('r', '0x11111114', 0),
           ('w', '0x11111118', 0)
          ],

          [
           ('r', '0x11111112', 0),
           ('w', '0x11111116', 0),
           ('r', '0x11111113', 0)
          ]
         ]

class Monitor(process):
  def setup():
    self.instructions = []
    self.total_msgs = 0
    self.cpu_time = 0
    self.elapsed_time = 0

  def receive(msg= ('ins', type, addr, value, cache_id)):
    instructions.append((type, addr, value, cache_id))

  def receive(msg= ('inc_msg_cnt', value)):
    total_msgs = total_msgs + value
  
  def receive(msg= ('time_taken', cpu, elapsed)):
    cpu_time = cpu
    elapsed_time = elapsed 

  def run():
    await(False)

  def receive(msg= ('done',)):
    print("Total msg count:", total_msgs)
    for ins in instructions:
      print(ins[3], ": ", ins[0], ins[1], ins[2])
    #print("CTRL Exiting\n")
    
    print("===Benchmarks===")
    print("Total msg count:", total_msgs)
    print("Elapsed time:", elapsed_time)
    print("CPU time:", cpu_time)
    exit()

def main():
    nprocessors = int(sys.argv[1]) if len(sys.argv) > 1 else 2
    proto_name = sys.argv[2] if len(sys.argv) > 2 else 'MSI'
    #trace_file = sys.argv[3] if len(sys.argv) > 3 else exit(-1)
    trace_file = sys.argv[3] if len(sys.argv) > 3 else 'none'

    config(channel= 'fifo', clock= 'Lamport')
    start_cpu_time = time.process_time()
    start_elapsed_time = time.perf_counter()

    trace = get_traces(trace_file)
    Proto_cache, Proto_ctrl = get_proto_class(proto_name)
    
    monitor_obj = new(Monitor, num=1)
    setup(monitor_obj, ())
    start(monitor_obj)
    
    ## Initialize protocol objs for caches and controller
    mem_ctrl_protocol_obj = new(Proto_ctrl, num=1)
    protocol_objs = new(Proto_cache, num=nprocessors)
    
    ## Setup Protocol for ctrller
    setup(mem_ctrl_protocol_obj, (protocol_objs, monitor_obj))
    start(mem_ctrl_protocol_obj)

    ## Setup Protocols for caches
    for proto_obj in protocol_objs:
      setup(proto_obj, (mem_ctrl_protocol_obj, protocol_objs - {proto_obj}, CACHE_SIZE, monitor_obj))
      start(proto_obj)

    ## Setup Processors
    processors = new(Processor, num= nprocessors)
    
    ## temp lists for iterating
    processors_list = list(processors)
    protocol_objs_list = list(protocol_objs)
    for i in range(nprocessors): 
      setup(processors_list[i], (trace[i], protocol_objs_list[i], monitor_obj))
    
    start(processors)
    
    ## Exiting logic  
    for p in processors: 
      p.join()

    da.send(('done',), to= protocol_objs)
    for m in protocol_objs:
      m.join()

    da.send(('done',), to= mem_ctrl_protocol_obj)
    for m in mem_ctrl_protocol_obj:
      m.join()
    
    end_cpu_time = time.process_time()
    end_elapsed_time = time.perf_counter()
    da.send(('time_taken', end_cpu_time-start_cpu_time, end_elapsed_time-start_elapsed_time), to= monitor_obj)
    
    da.send(('done',), to= monitor_obj)
    for monitor in monitor_obj:
      monitor.join() 

    print('-----END-----')

